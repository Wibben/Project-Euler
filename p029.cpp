/**
 * Problem 29: Distinct Powers
 * 
 * Consider all integer combinations of ab for 2 <= a <= 5 and 2 <= b <= 5:
 * 
 *     2^2=4, 2^3=8, 2^4=16, 2^5=32
 *     3^2=9, 3^3=27, 3^4=81, 3^5=243
 *     4^2=16, 4^3=64, 4^4=256, 4^5=1024
 *     5^2=25, 5^3=125, 5^4=625, 5^5=3125
 * 
 * If they are then placed in numerical order, with any repeats removed, 
 * we get the following sequence of 15 distinct terms:
 * 
 * 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
 * 
 * How many distinct terms are in the sequence generated by a^b for 
 * 2 <= a <= 100 and 2 <= b <= 100?
 */

#include <iostream>
#include <vector>
#include <map>
#include <cmath>
#include <algorithm>

using namespace std;

vector<int> primes;

void generate_primes(int max)
{
    bool is_prime;

    // Start by generating a list of primes <1000
    // 2 is the first and only even prime number
    primes.push_back(2);

    // Only need to look at odd numbers as all even numbers are divisible by 2
    // for(int i=3; i<2001000; i+=2) {
    for(int i=3; i<=max; i+=2) {
        is_prime = true;
        // Assuming the number is prime, if it is found to be non prime set the flag
        // to false and exit loop to check indivisibility
        for(int j=0,max_check=i; j<primes.size() && is_prime && primes[j]<max_check; j++) {
            if(i%primes[j]==0) is_prime = false;
            max_check = i/primes[j];
        }

        if(is_prime) primes.push_back(i);
    }
}

// Primes factorize and figure out if value is a perfect power
void reduce_powers(int *base, int *power)
{
    map<int,int> factors;
    int dividend = *base;
    int smallest_power = 1000000;
    bool is_perfect_power = true;

    // Prime factorize number
    while(dividend > 1) {
        for(int i=0; i<primes.size(); i++) {
            if(dividend % primes[i] == 0) {
                dividend /= primes[i];

                if(factors.find(primes[i]) == factors.end()) factors[primes[i]] = 1;
                else factors[primes[i]]++;
            }
        }
    }

    // Find the smallest power in the list, if it is just 1, then the number is just base^1
    for(map<int,int>::iterator it=factors.begin(); it!=factors.end(); it++) {
        if(it->second < smallest_power) smallest_power = it->second;
    }
    if(smallest_power==1) is_perfect_power = false;

    // Check if the number is a perfect power by checking if every power in the prime
    // factorization is divisible by the smallest power, if it is, divide it to prep for next step
    for(map<int,int>::iterator it=factors.begin(); it!=factors.end() && is_perfect_power; it++) {
        if(it->second % smallest_power != 0) is_perfect_power = false;
        else it->second /= smallest_power;
    } 

    // If it is a perfect power, then the power is smallest_power, base is the product of all the
    // remaining factors (after reduction)
    // otherwise, do nothing
    if(is_perfect_power) {
        *power = smallest_power;
        *base = 1;
        for(map<int,int>::iterator it=factors.begin(); it!=factors.end(); it++) {
            *base *= pow(it->first,it->second);
        }
    }
}

int main()
{
    // A list of bases and their respective powers done
    map<int,vector<int>> powers;
    int distinct_powers=0;
    int base, power;

    generate_primes(100);

    // Count perfect powers as extensions to the powers of its base to avoid double counting
    for(int a=2; a<=100; a++) {
        base = a; power = 1;
        reduce_powers(&base,&power);

        for(int b=2; b<=100; b++) {
            if(find(powers[base].begin(),powers[base].end(),power*b)==powers[base].end()) {
                powers[base].push_back(power*b);
                distinct_powers++;
            } 
        }
    }

    cout << "Total number of distinct powers is: " << distinct_powers << endl;

    return 0;
}